package bio.knowledge.service.beacon;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

import bio.knowledge.client.api.ConceptsApi;
import bio.knowledge.client.model.StatementsObject;
import bio.knowledge.client.model.StatementsPredicate;
import bio.knowledge.client.model.StatementsSubject;
import bio.knowledge.model.Annotation;
import bio.knowledge.model.AnnotationImpl;
import bio.knowledge.model.Concept;
import bio.knowledge.model.ConceptImpl;
import bio.knowledge.model.GeneralStatement;
import bio.knowledge.model.PredicateImpl;
import bio.knowledge.model.SemanticGroup;
import bio.knowledge.model.Statement;

/**
 * This class has static methods that use reflection to build the relevant model
 * object out of the response objects. This is useful because the response objects
 * can have their names changed (as they are generated by Swagger).
 * 
 * @author lance
 *
 */
@SuppressWarnings("unchecked")
public final class ModelConverter {
	
	private static <T> T callMethod(Object object, String methodName, Class<T> returnType) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException {
		return returnType.cast(object.getClass().getMethod(methodName).invoke(object));
	}
	
	public static Concept buildConcept(Object responseObject) {
		try {			
			String id = callMethod(responseObject, "getId", String.class);
			String name = callMethod(responseObject, "getName", String.class);
			String semanticGroup = callMethod(responseObject, "getSemanticGroup", String.class);
			List<String> synonyms = callMethod(responseObject, "getSynonyms", new ArrayList<String>().getClass());
			String definition = callMethod(responseObject, "getDefinition", String.class);
			ConceptImpl concept = new ConceptImpl(id, SemanticGroup.valueOf(semanticGroup, SemanticGroup.OBJC), name);
			concept.setDescription(definition);
			concept.setSynonyms(String.join(" ", synonyms));
			
			return concept;
			
		} catch (NoSuchMethodException | SecurityException e) {
			e.printStackTrace();
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	public static Statement buildStatement(Object responseObject) {
		try {
			String id = callMethod(responseObject, "getId", String.class);
			StatementsObject statementsObject = callMethod(responseObject, "getObject", StatementsObject.class);
			StatementsSubject statementsSubject = callMethod(responseObject, "getSubject", StatementsSubject.class);
			StatementsPredicate statementsPredicate = callMethod(responseObject, "getPredicate", StatementsPredicate.class);
			
			ConceptImpl subject = new ConceptImpl(statementsSubject.getId(), null, statementsSubject.getName());
			ConceptImpl object = new ConceptImpl(statementsObject.getId(), null, statementsObject.getName());
			PredicateImpl predicate = new PredicateImpl(statementsPredicate.getName());
			
			return new GeneralStatement(id, subject, predicate, object);
		} catch (NoSuchMethodException | SecurityException e) {
			e.printStackTrace();
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	public static Annotation buildAnnotation(Object responseObject) {
		try {
			String id = callMethod(responseObject, "getId", String.class);
			String name = callMethod(responseObject, "getLabel", String.class);
			String date = callMethod(responseObject, "getDate", String.class);
			
			Annotation annotation = new AnnotationImpl();
			annotation.setId(id);
			annotation.setName(name);
			annotation.setPublicationDate(date);
			
			return annotation;
		} catch (NoSuchMethodException | SecurityException e) {
			e.printStackTrace();
		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
			e.printStackTrace();
		}
		
		return null;
	}
}
